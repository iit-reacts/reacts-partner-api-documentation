{
  
  "1": {
    "title": "Account",
    "content": "Account API Allows partners to manage user accounts to which they own Swagger",
    "url": "/docs/api/account/",
    "relUrl": "/docs/api/account/"
  }
  ,"2": {
    "title": "API",
    "content": "Reacts APIs Overview Account API - Allows partners to manage user accounts to which they own Event API - The event api allows a partner to create a Reacts event and provide users with a url to join the Event. Referral API - This API allows the partner to create a referral on reacts system. Once the referral is claimed or shared the business logic agreed with the partner will be executed. A common example is a referral being converted into a reacts subscription",
    "url": "/docs/api",
    "relUrl": "/docs/api"
  }
  ,"3": {
    "title": "Authentication",
    "content": "Authentication The Reacts Partner API uses JWT tokens to authenticate requests. The JWT token should look like this: { &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot; }. { &quot;partnerid&quot;: &quot;&lt;partner-id&gt;&quot;, &quot;iss&quot;: &quot;partner url or name to identification of JWT issuer&quot; &quot;exp&quot;: 1550502442, &quot;nbf&quot;: 1549897642 }. HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), your-partner-key) &lt;your-partner-id&gt; and &lt;partner-key&gt; should be provided by Reacts Team upon Request. Your Partner key carry many privileges, so be sure to keep it secure! Do not share your Partner Key in publicly accessible areas such as GitHub, client-side code, and so forth. Notice that the authentication will fail if the field iss is not provided The JWT generated should be provided via bearer auth HTTP header, for example Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwYXJ0bmVyaWQiOiIxIiwicm9sZSI6IlBBUlRORVIiLCJpc3MiOiJodHRwczovL3d3dy5paXRyZWFjdHMuY29tIiwiYXVkIjoiaHR0cHM6Ly93d3cuaWl0cmVhY3RzLmNvbSIsImV4cCI6MTU1MDUwMjQ0MiwibmJmIjoxNTQ5ODk3NjQyfQ.KXPMSGM0vJb3dgsl8RlFQWDoFax23EGD8Lk67DuWBRk You can use the PartnerAuthentication endpoint to generate a valid JWT by providing a partner-id and partner-key. This endpoint is for testing only and it should not be used in production The pair of partner-key and partner-id is unique for each customer therefore if you are calling our API on behalf of an institution you should have one pair per institution and of course their consent. Please notice that you will need a different pair of partner-key and partner-id for each of our Environments. See Environments Swagger",
    "url": "/docs/authentication/",
    "relUrl": "/docs/authentication/"
  }
  ,"10": {
    "title": "Events",
    "content": "Webhook Events This is a list of all the types of events we currently notify partners. We may add more at any time, so in developing and maintaining your code, you should not assume that only these types exist. You’ll notice that these events follow a pattern: resource.event. Our goal is to design a consistent system that makes things easier to anticipate and code against. EVENT   room.created (room object) Occurs whenever a room is created room.deleted (room object) Occurs whenever a room is deleted room.participant.joined (participant object) Occurs whenever a participant joins a room room.participant.left (participant object) Occurs whenever a participant leaves a room WebhookNotification object ATTRIBUTES Type   id long Unique identifier for the object. webhookEndpointId string Unique identifier of the endpoint the notification was sent to eventName string Name of the event eventDatetime timestamp Date and time on which the event happened in seconds since the Unix epoch data object This is the specific data from the event { &quot;id&quot;: 124, &quot;webhookEndpointId&quot;: &quot;dde5402f-8bc5-47a4-8e46-a5d57c29222e&quot;, &quot;eventDatetime&quot;: 1564685397, &quot;eventName&quot;: &quot;room.participant.joined&quot;, &quot;data&quot;: &quot;&lt;specific object here&gt;&quot; } A notification of a room created would look like this { &quot;id&quot;: 124, &quot;webhookEndpointId&quot;: &quot;dde5402f-8bc5-47a4-8e46-a5d57c29222e&quot;, &quot;eventDatetime&quot;: 1564685397, &quot;eventName&quot;: &quot;room.created&quot;, &quot;data&quot;: { &quot;roomId&quot;: &quot;123ewa-8bc5-47a4-8e46-231wbddgtt&quot;, &quot;eventId&quot;: &quot;g6t5gg-8bc5-47a4-8e46-gezcs355&quot; } } Room object ATTRIBUTES Type   roomId string Unique identifier for the room object. eventId string Unique identifier for the corresponding event. { &quot;roomId&quot;: &quot;123ewa-8bc5-47a4-8e46-231wbddgtt&quot;, &quot;eventId&quot;: &quot;g6t5gg-8bc5-47a4-8e46-gezcs355&quot;, } Participant object ATTRIBUTES Type   participantId string Unique identifier for the participant. participantEmail string Email of the participant roomId string Unique identifier for the room the participant joined eventId string Unique identifier for the event the participant joined { &quot;participantId&quot;: &quot;123ewa-8bc5-47a4-8e46-231wbddgtt&quot;, &quot;participantEmail&quot;: &quot;firstname.lastname@domain.com&quot;, &quot;roomId&quot;: &quot;g6t5gg-8bc5-47a4-8e46-gezcs355&quot;, &quot;eventId&quot;: &quot;2e6f6904-bd7f-42a6-b069-70dec525dc43&quot; }",
    "url": "/docs/webhooks/events/",
    "relUrl": "/docs/webhooks/events/"
  }
  ,"11": {
    "title": "Events",
    "content": "Events API The Event api allows a partner to create a Reacts event and provide users with a url to join the Event. The Event api provides 3 methods available: POST /api/partner/events adds an event item and returns the event information including the event url GET /api/partner/events/{id} gets an event by ID that was previously created DELETE /api/partner/events/{id} cancels an event Creating a Reacts event Generate the a valid JWT as instructed in the Authentication page Do a POST /api/partner/events Retrive the eventUrl from the response Payload Element Name REQUIRED? Type Comments language no string en or fr (default: en) type no string currently only private events are supported videoMode no string video-enabled or video-muted (default: video-enabled) owner yes string email of the event’s owner. See details below title yes string title of the event description no string description of the event timeZoneId yes string timezone of start and end date. See column TZ database name. Please make the startDate and endDate are in the timezone specified on this property startDate yes date format: yyyy-dd-mm hh:mm endDate yes date format: yyyy-dd-mm hh:mm cancelEmailNotification yes boolean true or false invitees yes Invitee[] see comments below owner  The owner of the event should have an active account and a Pro subscription Only institutions that own the Pro subscription of the owner can create events on their behalf invitees There is no need to include the owner in the list of invitees since it will be included by default If invitee doesn’t have an account, an email will be sent notifying of the appointment and inviting the user to register If invitee already have an account, an email will be sent notifying the user that he/she were invited to a Reacts appointment by the owner Invitee Element Name REQUIRED? Type Comments id no guid reacts user id. If not provided the user email should be provided email no string email of the invitee. If not provided the id should be provided firstName yes string   lastName yes string   Cancelling a Reacts event Generate the a valid JWT as instructed in the Authentication page Do a DELETE /api/partner/events/{id}. {id} should be replaced by the event id returned when it was created Please note that the cancellation of an event: makes the event url unusable. will NOT close a session that has already started but invitees that have not joined yet will NOT be able to join anymore. will NOT notify all participants by email Swagger",
    "url": "/docs/api/events/",
    "relUrl": "/docs/api/events/"
  }
  ,"13": {
    "title": "Home",
    "content": "Overview Introduction Welcome to Reacts! Here you’ll find a comprehensive information for integrating with the Reacts platform. We’ve tried to make this documentation user-friendly and example-filled, but if you have any questions, please head to our Support If you’re planning to use our API in Production, take a look at our Privacy Policy and Terms &amp; Conditions. The fastest way to get your integration up and running is to use our Quickstart guide, which walks through different integration use cases step-by-step. Get started now API protocols The Reacts API uses HTTP POST/GET/PUT requests to communicate and HTTP response codes to indicate status and errors. All responses come in standard JSON. The Reacts API is served over HTTPS TLS v1.2+ to ensure data privacy; HTTP and HTTPS with TLS versions below 1.2 are not supported. All requests must include a Content-Type of application/json and the body must be valid JSON. Versioning We periodically release new versions of our API. We try our best to minimize breaking changes. In the case where a breaking change is introduced you will be notified. The current version is: Documentation Roadmap Improve Event API documentation Finish Quickstart Add SSO Quickstart Add Webhooks Quickstart Add Appointments Quickstart",
    "url": "/",
    "relUrl": "/"
  }
  ,"18": {
    "title": "Quickstart",
    "content": "Quickstart guide Use Cases Onboarding for Testing Going to Production Environments UAT (Development) Staging (Sandbox) Production Use Cases Enable users to join a video/audio call through a virtual appointment URL Many times you want to enable your users to join an appointment using a URL. Reacts API allows a partner organization to create appointments on behalf of their users so that they can retrieve the appointment URL. Enable users to connect on Reacts with Single Sign-On (SSO) Having your user manage multiple credentials can be annoying and inefficient TBD… Onboarding for Testing Contact our business development team or submit a ticket explaining your business and how would you like to use/integrate Reacts Once you have been approved as a Partner we will ask you for an email so we can create your test account on our Staging environment. At this point, a person will be appointed to you as your “point of contact” We will send you the following information once your partner account has been created Username and password to access reacts at https://staging.iitreacts.com/en/account/login You partner-id and partner-key so you can have access to our web API. See Authentication to learn how to use them If you need to use the Reacts SSO, You should provide us the ClientId and ClientSecret of your Identity Provider. See Single Sign-On Going to Production Contact your “point of contact” and let them know you want to move to Production You will receive a new set of partner-id and partner-key Point your system to the production URLs and start using Environments UAT (Development) Nightly build from master. Most recent changes add by our development team. You can expect some instability - Web API: https://uatsvc.iit-dev.com/ - Identity Provider Authority: https://uatidentity.iit-dev.com/ Staging (Sandbox) A stable environment that might include new features that will be deployed soon - Web API : https://stagingsvc.iitreacts.com/ - Identity Provider Authority: https://stagingidentity.iitreacts.com/ Production - Web API: https://svc.iitreacts.com/ - Identity Provider Authority: https://identity.iitreacts.com/",
    "url": "/docs/quickstart/",
    "relUrl": "/docs/quickstart/"
  }
  ,"21": {
    "title": "Single Sign-On",
    "content": "Single Sign-On Purpose Prerequisite Terms and Actors SSO Integration Flow References Purpose The purpose of this document is to describe the Single Sign-On (SSO) capabilities Reacts supports and the steps necessary to integrate your Identity Provider (IdP) with Reacts. The document is created for Developers, System Administrators or staff knowledgeable about SSO administration. The end goal is to allow a user that is registered in the partner system to seamlessly be transferred to the Reacts system so he/she can start communicating and collaborating with others without having to re-enter his/her credentials. Prerequisite OpenID Connect protocol Reacts uses the OpenID Connect/OAuth2 (OIDC) protocol to accomplish Single Sign-on with different partners. Reacts will act as a Service Provider and allows users to login either via Identity Provider Initiated flows or Service Provider initiated flow. From openid.net, “OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.” OIDC builds on the lessons of the early OpenID protocols and SAML2 including: keep things simple build on top of OAuth2 use easy-to-consume tokens (JWT) OIDC can integrate with traditional web applications mobile apps Single Page Applications (SPA apps) server applications most other actors Terms and Actors OpenID Connect defines a few terms/actors that play different roles in the protocol. We define them below. ID Token: A JWT token that identifies the user. See http://openid.net/specs/openid-connect-core-1_0.html#IDToken OpenID Provider (OP): OAuth 2.0 Authorization Server that is capable of Authenticating the End-User and providing Claims to a Relying Party (see below) about the Authentication event and the End-User (per the OIDC spec). In our context, the OP is the partner OpenID provider and is named as Partner IdP in the diagram below. Relying Party (RP): The application requiring End-User Authentication and Claims from an OpenID Provider. The OpenID Provider securely returns the Authentication Response to the application so that it can be relied upon; thus, the application is called a Relying Party in this context. In our context, the RP is the Reacts OpenID Provider and is named as Reacts IdP in the diagram below. End-User: The principal (user) that is authenticated (a human most likely). In our context, the End-User is a user that is registered in the Partner IdP and is trying to login in Reacts User Agent: Something that initiates HTTPS requests and can handle the redirects generated by the Relying Party and OpenID Provider. The User Agent is responsible from receiving the JWT from the OP and pushing it to the RP for validation. The user agent is usually going to be a User Agent or a library that can process the OIDC calls. In our context, the User Agent is the browser and is named as User-Browser in the diagram below. Resource Server: The server hosting the protected resources, capable of accepting and responding to protected resource requests using Access Tokens. The Resource server will allow access to the its resource if the Access token has the necessary scopes. In our context the Resource Server is the Reacts WebAPI. SSO Integration Flow OIDC defines different flows to achieve authentication. In this document we explain how to achieve the Implicit flow but Reacts IdP supports all the flows define by OIDC specification. Implicit Flow (OIDC v1.0 spec, Section 3.2): It returns the ID Token and optionally an Access Token directly to the user agent as part of the authentication response to the Authorization Endpoint. RPs that use the Implicit Flow can only be public clients (there is no client secret). The end user will click the link “Launch Reacts” in a browser (or other User Agent) that makes an initial request to the partner website. The partner website will redirect the user browser to reacts sso link - step [0]. The redirect url on step [1] will look something like this: https://www.reacts.com/Account/ExternalLogin?provider=&lt;partnerName&gt; Reacts Website will intercepts the request and detects that is not part of an authenticated session - step [2]; so, Reacts Website responds to the request with an HTTP Redirect to the Reacts IdP - step [3]. The Reacts IdP (RP) intercepts the request and detects that it is not part of an authenticated session; so, the RP responds to the request with an HTTP Redirect to the Partner IdP (OP) — step [4]. The Authentication Request sent to the partner Authorization Endpoint looks something like the following: GET https://partner.com/connect/authorize? client_id=s6BhdRkqt3 &amp;redirect_uri=https://identity.reacts.com/signin-oidc &amp;response_type=id_token &amp;scope=openid profile &amp;nonce=636534591111863504 &amp;state=CfDJ &amp;response_mode=form_post x-client-ver=2.1.4.0 The partner OP will redirect the User Browser to a login workflow. The details of how the authentication works are outside the scope of the OIDC spec and it might be custom to each partner. The authentication workflow can include the opportunity for the end user to grant consent to the RP to access resources owned by the end user. If user is already login with the Partner IdP user should not be prompt again for its credentials. Following a successful authentication, the OP will send an HTTP Redirect response to return the user to the Authorization Endpoint. The OIDC spec defines 3 different response_mode, the example used on this document is the form_post which is understood to be the most secure since the Token Id never travels in the URI. See https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html for more information. The OP should respond with a page that includes a form that looks like this: HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Cache-Control: no-cache, no-store Pragma: no-cache &lt;html&gt; &lt;head&gt;&lt;title&gt;Submit This Form&lt;/title&gt;&lt;/head&gt; &lt;body onload=&quot;javascript:document.forms[0].submit()&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;http://localhost:5000/signin-oidc&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;state&quot; value=&quot;DcP7csa3hMlvybERqcieLHrRzKBra&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;id_token&quot; value=&quot;eyJhbGciOi.removed-for-brevity&quot;/&gt; &lt;input type=&#39;hidden&#39; name=&#39;scope&#39; value=&#39;openid profile&#39; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; This page when load will auto POST the information to Reacts IdP - step [6], which will be able to validate and authentication the user OpenId Connect discovery document can be found here https://identity.reacts.com/.well-known/openid-configuration As part of the OIDC protocol the Partner IdP should also implement the discovery endpoint since all the information needed for the OIDC can be found on this document. See Section 3 of https://openid.net/specs/openid-connect-discovery-1_0.html References http://openid.net/connect/ https://medium.com/@robert.broeckelmann/saml-v2-0-vs-jwt-series-550551f4eb0d http://identityserver.io/ OIDC consists of the following specifications (from openid.net): Core (required): core OIDC functionality: authentication built on top of OAuth 2.0 and the use of Claims to communicate end-user information. Discovery (optional): How Clients dynamically discover information about OpenID Providers (ie, Authorization Servers or Identity Providers). Dynamic Registration (optional): how clients dynamically register with OpenID Providers. OAuth 2.0 Multiple Response Types (required): Defines several specific new OAuth 2.0 response types. OAuth 2.0 Form Post Response Mode (Optional): Defines how to return OAuth 2.0 Authorization Response parameters (including OIDC Authentication Response parameters) using HTML form values that are auto-submitted by the User Agent using HTTP POST Session Management (Optional): Defines how to manage OIDC sessions, including post Message-based logout functionality Front-Channel Logout (Optional): Defines a front-channel logout mechanism that does not use an OP iframe on RP pages Back-Channel Logout (Optional): Defines a logout mechanism that uses back-channel communication between the OP and RPs being logged out. Two implementer’s guides are also available to serve as self-contained references for implementers of basic Web-based Relying Parties: Basic Client Implementer’s Guide: Simple subset of the Core functionality for a web-based Relying Party using the OAuth code flow Implicit Client Implementer’s Guide: Simple subset of the Core functionality for a web-based Relying Party using the OAuth Implicit Flow Also, a protocol migration specification is available: OpenID 2.0 to OpenID Connect Migration 1.0: Defines how to migrate from OpenID 2.0 to OIDC",
    "url": "/docs/sso/",
    "relUrl": "/docs/sso/"
  }
  ,"22": {
    "title": "Swagger",
    "content": "Swagger {% swagger https://localsvc.iitreacts.com:8081/swagger/docs/v1/ PartnerWebhooks %}",
    "url": "/docs/webhooks/swagger/",
    "relUrl": "/docs/webhooks/swagger/"
  }
  ,"28": {
    "title": "Webhooks",
    "content": "Webhooks Setting Up Webhooks Subscribe for events Respond to webhook events Handle duplicate events Order of events CSRF protection HTTPS Manage webhook endpoints Retry logic Securing webhooks Challenge-Response Checks Signature header validation Preventing replay attacks Resources Setting Up Webhooks You can register webhook URLs for Reacts to notify any time an event that you subscribe happens in any of the user accounts your institution manages. When the event occurs—a user joins a call, a call has finished, etc.—Reacts creates an WebhookNotification object. This WebhookNotification object contains all the relevant information about what just happened, including the type of event and the data associated with that event. Reacts then sends the WebhookNotification object, via an HTTP POST request, to any endpoint URLs that you have defined. You can have Reacts send a single event to multiple endpoints or subscribe for multiple events with a single endpoint. To set up an endpoint, you need to define a route on your server for receiving events, configure webhook settings so Reacts knows where to POST events to, verify your endpoint is valid, and acknowledge your endpoint is receiving events successfully. Subscribe for events You can programatically create webhook subscriptions using the api/partner/webhooks endpoint. The api/partner/webhooks endpoint is protected therefore you will need a partner key which can be requested to IIT. Create a new Webhook subscription by doing a POST to api/partner/webhooks. This will trigger the Challenge-Response check (see below) to validate the authenticity of the destination URL Respond to webhook events To acknowledge receipt of a webhook notification, your endpoint must return a 2xx HTTP status code. We recommend acknowledging webhook notifications before any further processing to prevent timeouts. Your endpoint will be disabled if it fails to acknowledge events over consecutive retries. Reacts will wait for 20 seconds for your reply otherwise it will consider the request as failed. All response codes outside this range, including 3xx codes, indicate to Reacts that you did not receive the event. This does mean that a URL redirection or a “Not Modified” response is treated as a failure. Reacts ignores any other information returned in the request headers or request body. Handle duplicate events Webhook endpoints might occasionally receive the same event more than once. We advise you to guard against duplicated event receipts by making your event processing idempotent. One way of doing this is logging the events you’ve processed, and then not processing already-logged events. Order of events Reacts webhooks will do the best to deliver events in order but in case you detect that you have missed a message you can always call the endpoint below to fetch notifications since a particular id GET api/partner/webhooks/{webhookId}/notifications?since={lastNotificationIdReceived} CSRF protection If you’re using a web framework, your site might automatically check that every POST request contains a CSRF token. This is an important security feature that helps protect you and your users from cross-site request forgery attempts. However, this security measure might also prevent your site from processing legitimate events. If so, you might need to exempt the webhooks route from CSRF protection. HTTPS Reacts will not deliver events to a URL that is not under HTTPS. Reacts will validate that the connection to your server is secure before sending your webhook data. For this to work, your server must be correctly configured to support HTTPS with a valid certificate Manage webhook endpoints If you need to update or delete a webhook endpoint, you can do so using the webhook endpoints programmatically.. You also have the option of disabling a webhook endpoint temporarily. Reacts does not try/retry any notifications that are generated while the endpoint is disabled. Retry logic Reacts attempts to deliver your webhooks for up to three days with an exponential back off. Securing webhooks Reacts’ webhook-based APIs provide two methods for confirming the security of your webhook server: The challenge-response checks enables Reacts to confirm the ownership of the web app receiving webhook events. The signature header in each POST request enables you to confirm that Reacts is the source of the incoming webhooks. Challenge-Response Checks To verify that you are the owner of the app and the webhook URL, Reacts will perform a Challenge-Response Check (CRC), which is not to be confused with a cyclic redundancy check. When a CRC is sent, Reacts will make a GET request of your web app with a crcToken parameter. When that request is received, your web app needs to build an encrypted responseToken based on the crcToken parameter and your partner-key. The responseToken must be encoded in JSON (see example below) and returned within 3 seconds. When successful, a webhook id will be returned. A CRC will be sent when you register your webhook URL, so implementing your CRC response code is a fundamental first step. Once your webhook is established, Reacts will trigger a CRC every time you update your webhooks settings. Your app can also trigger a CRC when needed by making a PUT request with a webhook id. Triggering a CRC is useful as you develop your webhook application, after deploying new code and restarting your service. The crcToken should be expected to change for each incoming CRC request and should be used as the message in the calculation, where your Partner Key is the key. In the event that the response is not posted within 3 seconds or becomes invalid, events will cease to be sent to the registered webhook. The CRC request will occur: When a webhook URL is registered (POST). When a webhook URL is updated (PUT) You can manually trigger a CRC by making a PATCH request. As you develop your webhook client, you should plan on manually triggering the CRC as you develop your CRC response. Response requirements: A hexadecimal encoded HMAC SHA-256 hash created from the crcToken and your app Partner Key Valid responseToken and JSON format. Latency less than 3 seconds. 200 HTTP response code. Example response token generation Here is an example on how to generate the response token using javascript const crypto = require(&#39;crypto&#39;); app.get(&#39;/webhooks/reacts&#39;, function(request, response) { const hmac = crypto.createHmac(&#39;sha256&#39;, process.env.SECRET); hmac.on(&#39;readable&#39;, () =&gt; { const data = hmac.read(); if (data) { var hash = data.toString(&#39;hex&#39;); var r = { responseToken: hash }; response.send(r); } }); hmac.write(request.query.crcToken); hmac.end(); }); Example JSON response: With the route defined as above your webapp should return a response similar to below when navigating to https://your-app-domain/webhooks/reacts?crcToken=foo in your web browser. { &quot;responseToken&quot;: &quot;92d80831cfa935d5ef47e79fbbee5ca132b44f5c506aa16060c1fadaeafdb312&quot; } Signature header validation The x-reacts-signature header contains a timestamp and one or more signatures. The timestamp is prefixed by t=, and each signature is prefixed by a scheme. Schemes start with v, followed by an integer. Currently, the only valid signature scheme is v1. x-reacts-signature: t=1492774577, v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd Note that newlines have been added in the example above for clarity, but a real x-reacts-signature header will be all one line. Reacts generates signatures using a hash-based message authentication code (HMAC) with [SHA-256)(https://en.wikipedia.org/wiki/SHA-2). To prevent downgrade attacks, you should ignore all schemes that are not v1. It is possible to have multiple signatures with the same scheme/key pair. This can happen when you have more than one Partner Key active. During this time, your partner account has multiple active keys and Reacts generates one signature for each key. Receive multiple signatures would look like this: x-reacts-signature: t=1492774577, v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd, v1=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039989a39 Step 1: Extract the timestamp and signatures from the header Split the header, using the , (comma) character as the separator, to get a list of elements. Then split each element, using the = (equal) character as the separator, to get a prefix and value pair. The value for the prefix t corresponds to the timestamp, and v1 corresponds to the signature(s). You can discard all other elements. Step 2: Prepare the signed_payload string You achieve this by concatenating: The timestamp (as a string) The character . The actual JSON payload (i.e., the request’s body) Step 3: Determine the expected signature Compute an HMAC with the SHA256 hash function in hexadecimal format. Use the partner key as the key, and use the signed_payload string as the message. Step 4: Compare signatures Compare the signature(s) in the header to the expected signature. If a signature matches, compute the difference between the current timestamp and the received timestamp, then decide if the difference is within your tolerance. To protect against timing attacks, use a constant-time string comparison to compare the expected signature to each of the received signatures. Preventing replay attacks A replay attack is when an attacker intercepts a valid payload and its signature, then re-transmits them. To mitigate such attacks, Reacts includes a timestamp in the x-reacts-webhooks-signature header. Because this timestamp is part of the signed payload, it is also verified by the signature, so an attacker cannot change the timestamp without invalidating the signature. If the signature is valid but the timestamp is too old, you can have your application reject the payload. We recommend a tolerance of five minutes between the timestamp and the current time. We also recommend that you use Network Time Protocol (NTP) to ensure that your server’s clock is accurate and synchronizes with the time on Reacts’ servers. Reacts generates the timestamp and signature each time we send an event to your endpoint. If Reacts retries an event (e.g., your endpoint previously replied with a non-2xx status code), then we generate a new signature and timestamp for the new delivery attempt. Resources Sample code: https://glitch.com/edit/#!/jagged-bassoon",
    "url": "/docs/webhooks",
    "relUrl": "/docs/webhooks"
  }
  
}
